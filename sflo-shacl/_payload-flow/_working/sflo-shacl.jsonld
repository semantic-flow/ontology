{
  "@context": {
    "@base": "https://semantic-flow.github.io/ontology/semantic-flow-shacl/",
    "owl": "http://www.w3.org/2002/07/owl#",
    "vann": "http://purl.org/vocab/vann/",
    "sh": "http://www.w3.org/ns/shacl#",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "dcat": "http://www.w3.org/ns/dcat#",
    "dcterms": "http://purl.org/dc/terms/",
    "formats": "http://www.w3.org/ns/formats/",
    "sflo": "https://semantic-flow.github.io/semantic-flow-ontology/"
  },
  "@graph": [
    {
      "@id": "",
      "@type": "owl:Ontology",
      "dcterms:title": "Semantic Flow SHACL Shapes",
      "dcterms:description": "SHACL shapes for validating Semantic Flow data structures and operational invariants.",
      "vann:preferredNamespacePrefix": "sflo-shacl",
      "vann:preferredNamespaceUri": "https://semantic-flow.github.io/ontology/semantic-flow-shacl/"
    },
    {
      "@id": "MeshBaseShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "Mesh base sanity",
      "rdfs:comment": "Ensures a Mesh typically declares a canonical meshBase URI literal.",
      "sh:targetClass": {
        "@id": "sflo:Mesh/"
      },
      "sh:property": {
        "sh:path": {
          "@id": "sflo:meshBase/"
        },
        "sh:minCount": 1,
        "sh:maxCount": 1,
        "sh:datatype": {
          "@id": "xsd:anyURI"
        },
        "sh:severity": {
          "@id": "sh:Warning"
        },
        "sh:message": "A Mesh SHOULD declare exactly one sflo:meshBase (xsd:anyURI)."
      }
    },
    {
      "@id": "FlowArtifactStructureShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "FlowArtifact structure constraints",
      "rdfs:comment": "Basic structural constraints for FlowArtifact / slice membership.",
      "sh:targetClass": {
        "@id": "sflo:FlowArtifact/"
      },
      "sh:property": [
        {
          "sh:path": {
            "@id": "sflo:hasSlice/"
          },
          "sh:minCount": 1,
          "sh:severity": {
            "@id": "sh:Warning"
          },
          "sh:message": "A FlowArtifact SHOULD have at least one sflo:hasSlice."
        },
        {
          "sh:path": {
            "@id": "sflo:currentSlice/"
          },
          "sh:maxCount": 1,
          "sh:class": {
            "@id": "sflo:WorkingSlice/"
          },
          "sh:severity": {
            "@id": "sh:Violation"
          },
          "sh:message": "If present, a FlowArtifact's sflo:currentSlice MUST be a sflo:WorkingSlice (and at most one value)."
        }
      ],
      "sh:sparql": {
        "@type": "sh:SPARQLConstraint",
        "sh:message": "If sflo:currentSlice is present, its value MUST also be one of the FlowArtifact's sflo:hasSlice values.",
        "sh:severity": {
          "@id": "sh:Violation"
        },
        "sh:select": "SELECT $this WHERE {\n  $this sflo:currentSlice ?cs .\n  FILTER NOT EXISTS { $this sflo:hasSlice ?cs }\n}"
      }
    },
    {
      "@id": "SliceRealizableShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "Slice realization presence",
      "rdfs:comment": "Slices are content-bearing; they should usually have at least one AbstractFile realization.",
      "sh:targetClass": {
        "@id": "sflo:Slice/"
      },
      "sh:property": {
        "sh:path": {
          "@id": "sflo:hasAbstractFile/"
        },
        "sh:minCount": 1,
        "sh:severity": {
          "@id": "sh:Warning"
        },
        "sh:message": "A Slice SHOULD have at least one sflo:hasAbstractFile (realization spec)."
      }
    },
    {
      "@id": "SimpleArtifactRealizableShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "SimpleArtifact realization presence",
      "rdfs:comment": "SimpleArtifacts are realizable; they should usually have at least one AbstractFile realization.",
      "sh:targetClass": {
        "@id": "sflo:SimpleArtifact/"
      },
      "sh:property": {
        "sh:path": {
          "@id": "sflo:hasAbstractFile/"
        },
        "sh:minCount": 1,
        "sh:severity": {
          "@id": "sh:Warning"
        },
        "sh:message": "A SimpleArtifact SHOULD have at least one sflo:hasAbstractFile (realization spec)."
      }
    },
    {
      "@id": "AbstractFileLocatedFileShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "AbstractFile should be locatable (usually)",
      "rdfs:comment": "In many meshes, AbstractFiles are expected to have at least one LocatedFile. This is a warning because external/non-locatable realization specs may exist.",
      "sh:targetClass": {
        "@id": "sflo:AbstractFile/"
      },
      "sh:property": {
        "sh:path": {
          "@id": "sflo:hasLocatedFile/"
        },
        "sh:minCount": 1,
        "sh:severity": {
          "@id": "sh:Warning"
        },
        "sh:message": "An AbstractFile SHOULD have at least one sflo:hasLocatedFile."
      }
    },
    {
      "@id": "AbstractArtifactFileLocatedArtifactFileShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "AbstractArtifactFile locatability",
      "rdfs:comment": "Mesh-governed abstract artifact files should typically be backed by at least one mesh-governed located artifact file.",
      "sh:targetClass": {
        "@id": "sflo:AbstractArtifactFile/"
      },
      "sh:property": {
        "sh:path": {
          "@id": "sflo:hasLocatedArtifactFile/"
        },
        "sh:minCount": 1,
        "sh:severity": {
          "@id": "sh:Warning"
        },
        "sh:message": "An AbstractArtifactFile SHOULD have at least one sflo:hasLocatedArtifactFile."
      }
    },
    {
      "@id": "LocatedArtifactFileBacklinkShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "LocatedArtifactFile backlink",
      "rdfs:comment": "Located artifact files should usually indicate which abstract artifact file they locate.",
      "sh:targetClass": {
        "@id": "sflo:LocatedArtifactFile/"
      },
      "sh:property": {
        "sh:path": {
          "@id": "sflo:locatesAbstractArtifactFile/"
        },
        "sh:minCount": 1,
        "sh:maxCount": 1,
        "sh:severity": {
          "@id": "sh:Warning"
        },
        "sh:message": "A LocatedArtifactFile SHOULD locate exactly one AbstractArtifactFile via sflo:locatesAbstractArtifactFile."
      }
    },
    {
      "@id": "KnopPayloadChoiceShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "Knop payload choice",
      "rdfs:comment": "A Knop should have exactly one payload form: either a flow payload or a simple payload.",
      "sh:targetClass": {
        "@id": "sflo:Knop/"
      },
      "sh:xone": [
        {
          "@type": "sh:NodeShape",
          "sh:property": [
            {
              "sh:path": {
                "@id": "sflo:hasFlowPayload/"
              },
              "sh:minCount": 1,
              "sh:maxCount": 1
            },
            {
              "sh:path": {
                "@id": "sflo:hasSimplePayload/"
              },
              "sh:maxCount": 0
            }
          ]
        },
        {
          "@type": "sh:NodeShape",
          "sh:property": [
            {
              "sh:path": {
                "@id": "sflo:hasSimplePayload/"
              },
              "sh:minCount": 1,
              "sh:maxCount": 1
            },
            {
              "sh:path": {
                "@id": "sflo:hasFlowPayload/"
              },
              "sh:maxCount": 0
            }
          ]
        }
      ],
      "sh:message": "A Knop MUST have exactly one of: sflo:hasFlowPayload or sflo:hasSimplePayload (and not both)."
    },
    {
      "@id": "KnopMetadataFlowShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "Knop metadata flow presence",
      "rdfs:comment": "Operationally recommended: a Knop should have exactly one metadata flow.",
      "sh:targetClass": {
        "@id": "sflo:Knop/"
      },
      "sh:property": {
        "sh:path": {
          "@id": "sflo:hasKnopMetadataFlow/"
        },
        "sh:minCount": 1,
        "sh:maxCount": 1,
        "sh:severity": {
          "@id": "sh:Warning"
        },
        "sh:message": "A Knop SHOULD have exactly one sflo:hasKnopMetadataFlow."
      }
    },
    {
      "@id": "NomenReferenceLinksShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "Nomen reference links",
      "rdfs:comment": "Basic expectations for Nomen reference-link usage.",
      "sh:targetClass": {
        "@id": "sflo:Nomen/"
      },
      "sh:property": [
        {
          "sh:path": {
            "@id": "sflo:hasReferenceLink/"
          },
          "sh:class": {
            "@id": "sflo:ReferenceLink/"
          },
          "sh:severity": {
            "@id": "sh:Violation"
          },
          "sh:message": "Values of sflo:hasReferenceLink must be typed sflo:ReferenceLink."
        },
        {
          "sh:path": {
            "@id": "sflo:hasChildNomen/"
          },
          "sh:severity": {
            "@id": "sh:Info"
          },
          "sh:message": "sflo:hasChildNomen is operational/derived; validate only if present."
        }
      ]
    },
    {
      "@id": "ReferenceLinkBackpointerShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "ReferenceLink backpointer",
      "rdfs:comment": "A ReferenceLink should identify the thing it is about.",
      "sh:targetClass": {
        "@id": "sflo:ReferenceLink/"
      },
      "sh:property": {
        "sh:path": {
          "@id": "sflo:referenceLinkFor/"
        },
        "sh:minCount": 1,
        "sh:maxCount": 1,
        "sh:class": {
          "@id": "sflo:ArtifactHost/"
        },
        "sh:severity": {
          "@id": "sh:Warning"
        },
        "sh:message": "A ReferenceLink SHOULD point back to exactly one sflo:ArtifactHost via sflo:referenceLinkFor."
      }
    }
  ]
}
