{
  "@context": {
    "@base": "https://semantic-flow.github.io/ontology/semantic-flow-shacl/",
    "owl": "http://www.w3.org/2002/07/owl#",
    "vann": "http://purl.org/vocab/vann/",
    "sh": "http://www.w3.org/ns/shacl#",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "dcat": "http://www.w3.org/ns/dcat#",
    "dcterms": "http://purl.org/dc/terms/",
    "schema": "https://schema.org/",
    "sflo": "https://semantic-flow.github.io/semantic-flow-ontology/",
    "sh:targetClass": {
      "@type": "@id"
    },
    "sh:targetSubjectsOf": {
      "@type": "@id"
    },
    "sh:path": {
      "@type": "@id"
    },
    "sh:class": {
      "@type": "@id"
    },
    "sh:nodeKind": {
      "@type": "@id"
    },
    "sh:severity": {
      "@type": "@id"
    },
    "sh:datatype": {
      "@type": "@id"
    }
  },
  "@graph": [
    {
      "@id": "",
      "@type": "owl:Ontology",
      "dcterms:title": "Semantic Flow SHACL Shapes",
      "dcterms:description": "SHACL shapes for validating Semantic Flow data structures and operational invariants.",
      "vann:preferredNamespacePrefix": "sflo-shacl",
      "vann:preferredNamespaceUri": "https://semantic-flow.github.io/ontology/semantic-flow-shacl/"
    },
    {
      "@id": "MeshBaseShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "Mesh base sanity",
      "rdfs:comment": "Ensures a Mesh typically declares a canonical meshBase URI literal.",
      "sh:targetClass": "sflo:Mesh/",
      "sh:property": {
        "sh:path": "sflo:meshBase/",
        "sh:minCount": 1,
        "sh:maxCount": 1,
        "sh:datatype": "xsd:anyURI",
        "sh:severity": "sh:Warning",
        "sh:message": "A Mesh SHOULD declare exactly one sflo:meshBase (xsd:anyURI)."
      }
    },
    {
      "@id": "NomenDesignatorPathShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "Nomen designatorPath",
      "rdfs:comment": "Nomens must have exactly one mesh-relative designatorPath token.",
      "sh:targetClass": "sflo:Nomen/",
      "sh:property": {
        "sh:path": "sflo:designatorPath/",
        "sh:minCount": 1,
        "sh:maxCount": 1,
        "sh:datatype": "xsd:string",
        "sh:severity": "sh:Violation",
        "sh:message": "A Nomen MUST declare exactly one sflo:designatorPath (xsd:string)."
      }
    },
    {
      "@id": "FlowArtifactStructureShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "FlowArtifact structure",
      "rdfs:comment": "Basic structural constraints for slice membership (targeted by property use; does not require rdf:type or RDFS inference).",
      "sh:targetSubjectsOf": "sflo:hasSlice/",
      "sh:property": [
        {
          "sh:path": "sflo:hasSlice/",
          "sh:minCount": 1,
          "sh:nodeKind": "sh:IRI",
          "sh:severity": "sh:Warning",
          "sh:message": "A FlowArtifact SHOULD have at least one sflo:hasSlice."
        }
      ]
    },
    {
      "@id": "SliceRealizableShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "Slice realization presence",
      "rdfs:comment": "Slices are content-bearing; they should usually have at least one AbstractFile realization.",
      "sh:targetClass": "sflo:Slice/",
      "sh:property": {
        "sh:path": "sflo:hasAbstractFile/",
        "sh:minCount": 1,
        "sh:severity": "sh:Warning",
        "sh:message": "A Slice SHOULD have at least one sflo:hasAbstractFile (realization spec)."
      }
    },
    {
      "@id": "SimpleRealizableShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "Simple realizable realization presence",
      "rdfs:comment": "Simple realizables should usually have at least one AbstractFile realization. Explicitly targets leaf classes to avoid requiring RDFS inference.",
      "sh:targetClass": [
        "sflo:SimpleArtifact/",
        "sflo:SimplePayload/",
        "sflo:MeshInventoryDataset/",
        "sflo:KnopInventoryDataset/",
        "sflo:NomenInventoryDataset/"
      ],
      "sh:property": {
        "sh:path": "sflo:hasAbstractFile/",
        "sh:minCount": 1,
        "sh:severity": "sh:Warning",
        "sh:message": "A realizable SHOULD have at least one sflo:hasAbstractFile (realization spec)."
      }
    },
    {
      "@id": "AbstractFileLocatedFileShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "AbstractFile should be locatable (usually)",
      "rdfs:comment": "Many meshes expect AbstractFiles to have at least one LocatedFile. Warning because some realization specs may be non-locatable.",
      "sh:targetClass": "sflo:AbstractFile/",
      "sh:property": {
        "sh:path": "sflo:hasLocatedFile/",
        "sh:minCount": 1,
        "sh:severity": "sh:Warning",
        "sh:message": "An AbstractFile SHOULD have at least one sflo:hasLocatedFile."
      }
    },
    {
      "@id": "ReferenceLinkShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "ReferenceLink basics",
      "rdfs:comment": "A ReferenceLink must identify the thing it is about.",
      "sh:targetClass": "sflo:ReferenceLink/",
      "sh:property": [
        {
          "sh:path": "sflo:referenceLinkFor/",
          "sh:minCount": 1,
          "sh:maxCount": 1,
          "sh:nodeKind": "sh:IRI",
          "sh:severity": "sh:Violation",
          "sh:message": "A ReferenceLink MUST have exactly one sflo:referenceLinkFor."
        },
        {
          "sh:path": "sflo:hasReferenceRole/",
          "sh:minCount": 1,
          "sh:severity": "sh:Warning",
          "sh:message": "A ReferenceLink SHOULD have at least one sflo:hasReferenceRole."
        },
        {
          "sh:path": "sflo:referenceUriLiteral/",
          "sh:datatype": "xsd:anyURI",
          "sh:severity": "sh:Info",
          "sh:message": "If present, sflo:referenceUriLiteral must be xsd:anyURI."
        }
      ]
    },
    {
      "@id": "KnopPayloadChoiceShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "Knop payload choice",
      "rdfs:comment": "A Knop must have exactly one payload form: either FlowPayload or SimplePayload (accepts either specific properties or the generic containment predicate).",
      "sh:targetClass": "sflo:Knop/",
      "sh:xone": [
        {
          "@type": "sh:NodeShape",
          "sh:property": [
            {
              "sh:path": {
                "sh:alternativePath": [
                  "sflo:containsFlowPayload/",
                  "sflo:containsMeshResource/"
                ]
              },
              "sh:qualifiedValueShape": {
                "sh:class": "sflo:FlowPayload/"
              },
              "sh:qualifiedMinCount": 1,
              "sh:qualifiedMaxCount": 1
            },
            {
              "sh:path": {
                "sh:alternativePath": [
                  "sflo:containsSimplePayload/",
                  "sflo:containsMeshResource/"
                ]
              },
              "sh:qualifiedValueShape": {
                "sh:class": "sflo:SimplePayload/"
              },
              "sh:qualifiedMaxCount": 0
            }
          ]
        },
        {
          "@type": "sh:NodeShape",
          "sh:property": [
            {
              "sh:path": {
                "sh:alternativePath": [
                  "sflo:containsSimplePayload/",
                  "sflo:containsMeshResource/"
                ]
              },
              "sh:qualifiedValueShape": {
                "sh:class": "sflo:SimplePayload/"
              },
              "sh:qualifiedMinCount": 1,
              "sh:qualifiedMaxCount": 1
            },
            {
              "sh:path": {
                "sh:alternativePath": [
                  "sflo:containsFlowPayload/",
                  "sflo:containsMeshResource/"
                ]
              },
              "sh:qualifiedValueShape": {
                "sh:class": "sflo:FlowPayload/"
              },
              "sh:qualifiedMaxCount": 0
            }
          ]
        }
      ],
      "sh:message": "A Knop MUST have exactly one of: FlowPayload or SimplePayload (and not both)."
    },
    {
      "@id": "KnopSlotsShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "Knop slots",
      "rdfs:comment": "Enforces per-class slot cardinalities for common Knop-contained artifacts.",
      "sh:targetClass": "sflo:Knop/",
      "sh:property": [
        {
          "sh:path": {
            "sh:alternativePath": [
              "sflo:containsKnopMetadataFlow/",
              "sflo:containsMeshResource/"
            ]
          },
          "sh:qualifiedValueShape": {
            "sh:class": "sflo:KnopMetadataFlow/"
          },
          "sh:qualifiedMinCount": 1,
          "sh:qualifiedMaxCount": 1,
          "sh:severity": "sh:Violation",
          "sh:message": "A Knop MUST have exactly one KnopMetadataFlow."
        },
        {
          "sh:path": {
            "sh:alternativePath": [
              "sflo:containsKnopInventoryDataset/",
              "sflo:containsMeshResource/"
            ]
          },
          "sh:qualifiedValueShape": {
            "sh:class": "sflo:KnopInventoryDataset/"
          },
          "sh:qualifiedMinCount": 1,
          "sh:qualifiedMaxCount": 1,
          "sh:severity": "sh:Violation",
          "sh:message": "A Knop MUST have exactly one KnopInventoryDataset."
        }
      ]
    },
    {
      "@id": "MeshSlotsShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "Mesh slots",
      "rdfs:comment": "Enforces per-class slot cardinalities for common Mesh-contained artifacts.",
      "sh:targetClass": "sflo:Mesh/",
      "sh:property": [
        {
          "sh:path": {
            "sh:alternativePath": [
              "sflo:containsMeshInventoryDataset/",
              "sflo:containsMeshResource/"
            ]
          },
          "sh:qualifiedValueShape": {
            "sh:class": "sflo:MeshInventoryDataset/"
          },
          "sh:qualifiedMinCount": 1,
          "sh:qualifiedMaxCount": 1,
          "sh:severity": "sh:Violation",
          "sh:message": "A Mesh MUST have exactly one MeshInventoryDataset."
        },
        {
          "sh:path": {
            "sh:alternativePath": [
              "sflo:containsMeshMetadataFlow/",
              "sflo:containsMeshResource/"
            ]
          },
          "sh:qualifiedValueShape": {
            "sh:class": "sflo:MeshMetadataFlow/"
          },
          "sh:qualifiedMinCount": 1,
          "sh:qualifiedMaxCount": 1,
          "sh:severity": "sh:Violation",
          "sh:message": "A Mesh may have at most one MeshMetadataFlow."
        }
      ]
    },
    {
      "@id": "NomenSlotsShape/",
      "@type": "sh:NodeShape",
      "rdfs:label": "Nomen slots",
      "rdfs:comment": "Enforces per-class slot cardinalities for common Nomen-contained artifacts.",
      "sh:targetClass": "sflo:Nomen/",
      "sh:property": [
        {
          "sh:path": {
            "sh:alternativePath": [
              "sflo:containsNomenInventoryDataset/",
              "sflo:containsMeshResource/"
            ]
          },
          "sh:qualifiedValueShape": {
            "sh:class": "sflo:NomenInventoryDataset/"
          },
          "sh:qualifiedMinCount": 1,
          "sh:qualifiedMaxCount": 1,
          "sh:severity": "sh:Violation",
          "sh:message": "A Nomen MUST have exactly one NomenInventoryDataset."
        },
        {
          "sh:path": {
            "sh:alternativePath": [
              "sflo:containsNomenMetadataFlow/",
              "sflo:containsMeshResource/"
            ]
          },
          "sh:qualifiedValueShape": {
            "sh:class": "sflo:NomenMetadataFlow/"
          },
          "sh:qualifiedMinCount": 1,
          "sh:qualifiedMaxCount": 1,
          "sh:severity": "sh:Violation",
          "sh:message": "A Nomen may have at most one NomenMetadataFlow."
        },
        {
          "sh:path": "sflo:hasReferenceLink/",
          "sh:class": "sflo:ReferenceLink/",
          "sh:severity": "sh:Violation",
          "sh:message": "Values of sflo:hasReferenceLink must be typed sflo:ReferenceLink."
        }
      ]
    }
  ]
}
